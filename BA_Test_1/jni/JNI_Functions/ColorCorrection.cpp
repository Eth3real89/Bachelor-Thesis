#include "Functions/ProcessingFunctions.hpp"
#include "JNI_FUNCTIONS/JNI_Functions.hpp"
#include "Constants.hpp"

using namespace std;

#ifdef __cplusplus
extern "C" {
#endif
	/**
		\brief Java Native Interface function called from Java which delegates the retrieval of the color correction factors and the retrieval of the data to be visualized in the ANDROID UI

		@param env a JNIEnv pointer variable pointing to the Java Native Interface Environment variable
		@param jo a jobject variable containing an object of the Java Class calling this function
		@param frameAddress a jlong variable containing the memory address of a cv::Mat object containing frame data which is generated by Java via the camera
		@param ccvWidth a jint containing the width of the camera view in pixels
		@param ccvHeight a jint containing the height of the camera view in pixels
		@param srX a jint variable containing the x coordinate of the scan rectangle used to retrieve color values
		@param srY a jint variable containing the y coordinate of the scan rectangle used to retrieve color values
		@param srWidth a jint variable containing the width of the scan rectangle in pixels
		@param srHeight a jint variable containing the height of the scan rectangle in pixels
		@param filepath a jstring variable containing the file path to the configuration xml file

		Calculates all data needed for visualization in the Android UI and stores it into a two dimensional data structure. The data is casted to a String[][] in the Java Environment

		@see proc::gnrc::calibrate()
		@see getUIDisplayalInformation()

		@see Java/Android Component Documentation
		@see de.ur.juergenhahn.ba.Handler.NativeHandler.configurate()

		@return a jobjectArray containing jobjectArrays containing objects with the name of the board, names of the components, number of occurrences and whether they have polarity or not
	*/
	JNIEXPORT jobjectArray JNICALL Java_de_ur_juergenhahn_ba_Handler_NativeHandler_calibrateNative(JNIEnv * env, jobject jo, jlong frameAddress, jint ccvWidth, jint ccvHeight, jint srX, jint srY, jint srWidth, jint srHeight, jstring filepath)
	{
		cv::Mat & mat = *(cv::Mat *) frameAddress;

		const char * path = env->GetStringUTFChars(filepath, 0);

		jobjectArray rows;
		vector<vector<string>> strings;

		proc::gnrc::calibrate(strings, mat, ccvWidth, ccvHeight, srX, srY, srWidth, srHeight, string(path));

		getUIDisplayalInformation(& rows, strings, env);

		env->ReleaseStringUTFChars(filepath, path);

		return rows;
	}

#ifdef __cplusplus
}
#endif

/**
	\brief static function

	@param[out] rows a jobjectArray pointer variable pointing to the target buffer as function output
	@param[in] strings a constant reference of a std::vector of std::vectors containing the needed data
	@param[in] env a JNIEnv * variable pointing to the Java Native Interface Environment variable

	Delegates buffer building to uiInfos() function if strings data structure has data or else creates an empty jobjectArray

	@see uiInfos()
*/
static void getUIDisplayalInformation(jobjectArray * rows, std::vector<std::vector<string>> const & strings, JNIEnv * env)
{
	if(strings.size() > 0)
		uiInfos(rows, strings, env);
	else
		*rows = env->NewObjectArray(0, env->GetObjectClass(env->FindClass(cnst::JAVA_STRING_CLASS_IDENTIFIER)), 0);
}

/**
	\brief static function

	@param[out] rows a jobjectArray pointer variable pointing to the target buffer as function output
	@param[in] strings a constant reference of a std::vector of std::vectors containing the needed data
	@param[in] env a JNIEnv * variable pointing to the Java Native Interface Environment variable

	@see row()

	Creates the Java data structure filled with the data of strings data structure

	@see getUIDisplayalInformation()
*/
static void uiInfos(jobjectArray * rows, vector<vector<string>> const & strings, JNIEnv * env)
{
	for(int i = 0; i < strings.size(); i++)
	{
		const char * buf[strings[i].size()];

		for(int k = 0; k < strings[i].size(); k++) buf[k] = (strings[i][k]).c_str();

		jobjectArray jBuf = row(env, (jsize) strings[i].size(), buf);

		if(i == 0) *rows = env->NewObjectArray(strings.size(), env->GetObjectClass(jBuf), 0);

		env->SetObjectArrayElement(*rows, (jsize) i, jBuf);
	}
}

/**
	\brief a static function

	@param env a JNIEnv * variable pointing to the Java Native Interface Environment variable
	@param count a jsize variable containing the amount of elements of the data structure
	@param elements a constant char pointer pointing to a pointer pointing to char variables containing the retrieved data

	Creates a jobjectArray which contains the retrieved data

	@return a jobjectArray which contains the retrieved data
*/
static jobjectArray row(JNIEnv * env, jsize count, const char ** elements)
{
	jclass stringClass = env->FindClass(cnst::JAVA_STRING_CLASS_IDENTIFIER);
	jobjectArray row = env->NewObjectArray(count, stringClass, 0);
	jsize i;

	for(i = 0; i < count; i++)
		env->SetObjectArrayElement(row, i, env->NewStringUTF(elements[i]));

	return row;
}

